
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Live Camera Feed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-black text-white font-sans antialiased">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Helper Components ---

        const CameraIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 mx-auto text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                <path strokeLinecap="round" strokeLinejoin="round" d="M15 10l4.55a1 1 0 011.45.89V19a2 2 0 01-2 2H5a2 2 0 01-2 2V5a2 2 0 012-2h3.172a2 2 0 011.414.586l.828.828A2 2 0 009.828 5H13a2 2 0 012 2v3m-2 4h.01" />
            </svg>
        );

        // --- Main App Component ---

        function App() {
            const [permissionStatus, setPermissionStatus] = useState('idle');
            const [stream, setStream] = useState(null);
            const [error, setError] = useState(null);
            const [wakeLock, setWakeLock] = useState(null);
            const videoRef = useRef(null);

            const requestWakeLock = useCallback(async () => {
                if ('wakeLock' in navigator && 'permissions' in navigator) {
                    try {
                        // Query the permission status first to avoid errors.
                        const wakeLockPermissionStatus = await navigator.permissions.query({ name: 'screen-wake-lock' });
                        if (wakeLockPermissionStatus.state === 'granted' || wakeLockPermissionStatus.state === 'prompt') {
                            const lock = await navigator.wakeLock.request('screen');
                            setWakeLock(lock);
                            lock.addEventListener('release', () => {
                                setWakeLock(null);
                            });
                        } else {
                            console.warn('Screen Wake Lock permission is denied by browser policy.');
                        }
                    } catch (err) {
                        // This will catch any other unexpected errors.
                        console.error(`Wake Lock handling failed: ${err.name}, ${err.message}`);
                    }
                } else {
                    console.warn('Wake Lock API or Permissions API not supported.');
                }
            }, []);

            const handleRequestPermissions = useCallback(async () => {
                setPermissionStatus('pending');
                setError(null);
                try {
                    const mediaStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' },
                    });
                    setStream(mediaStream);
                    setPermissionStatus('granted');
                    if (document.visibilityState === 'visible') {
                        requestWakeLock();
                    }
                } catch (err) {
                    console.error("Error accessing media devices.", err);
                    if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
                        setError("Permission denied. Please allow camera access in your browser settings.");
                    } else {
                        setError(`An error occurred: ${err.name}. This may be because another app is using the camera or access is restricted.`);
                    }
                    setPermissionStatus('denied');
                }
            }, [requestWakeLock]);

            // Effect to automatically request permissions on load
            useEffect(() => {
                handleRequestPermissions();
            }, [handleRequestPermissions]);
            
            // Effect to manage stream and video element
            useEffect(() => {
                if (permissionStatus === 'granted' && stream && videoRef.current) {
                    const videoElement = videoRef.current;
                    // Only assign the stream if it's not already set. This prevents interruptions.
                    if (videoElement.srcObject !== stream) {
                        videoElement.srcObject = stream;
                        videoElement.play().catch(e => {
                            // Ignore AbortError which can happen if the play request is interrupted.
                            if (e.name !== 'AbortError') {
                                console.error("Error playing video:", e);
                            }
                        });
                    }
                }
            }, [permissionStatus, stream]);
            
            // Effect for cleanup on unmount
            useEffect(() => {
              return () => {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                if (wakeLock) {
                    wakeLock.release();
                }
              }
            }, [stream, wakeLock]);

            // Effect for handling visibility change
            useEffect(() => {
                const handleVisibilityChange = () => {
                    if (document.visibilityState === 'visible' && stream) {
                        requestWakeLock();
                    }
                };

                document.addEventListener('visibilitychange', handleVisibilityChange);
                return () => {
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                };
            }, [stream, requestWakeLock]);

            const renderContent = () => {
                switch (permissionStatus) {
                    case 'granted':
                        return (
                            <div className="relative w-full h-full">
                                {/* The video fills the screen but is invisible, ensuring the stream is active */}
                                <video ref={videoRef} muted playsInline className="absolute inset-0 w-full h-full object-cover opacity-0"></video>
                                <div className="absolute inset-0 flex flex-col justify-center items-center text-center text-gray-600 pointer-events-none" aria-hidden="true">
                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 mb-4 animate-pulse" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                                    </svg>
                                    <p className="text-sm font-medium">Camera Active</p>
                                    <p className="text-xs text-gray-700 mt-1">Screen is intentionally dark.</p>
                                </div>
                            </div>
                        );
                    case 'denied':
                        return (
                            <div className="text-center p-8 flex flex-col justify-center items-center h-full">
                                <h2 className="text-2xl font-bold text-red-400 mb-4">Access Denied</h2>
                                <p className="text-gray-300 max-w-md">{error}</p>
                                <p className="text-gray-400 mt-4 text-sm">You may need to go into your iPhone's Settings &gt; Chrome &gt; and enable Camera access.</p>
                                <button
                                    onClick={handleRequestPermissions}
                                    className="mt-8 bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-bold py-3 px-6 rounded-lg transition-colors"
                                >
                                    Retry
                                </button>
                            </div>
                        );
                    case 'pending':
                         return (
                            <div className="text-center p-8 flex flex-col justify-center items-center h-full animate-pulse">
                                 <CameraIcon />
                                 <h2 className="text-2xl font-bold mt-6">Awaiting Permissions...</h2>
                                 <p className="text-gray-400 mt-2">Please allow access in the browser prompt.</p>
                             </div>
                         );
                    case 'idle':
                    default:
                        return (
                            <div className="text-center p-8 flex flex-col justify-center items-center h-full">
                                <CameraIcon />
                                <h2 className="text-2xl font-bold mt-6">Initializing...</h2>
                            </div>
                        );
                }
            };
            
            return (
                <main className="h-[100svh] w-screen overflow-hidden flex flex-col items-center justify-center">
                    {renderContent()}
                </main>
            );
        }

        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(
            <React.StrictMode>
                <App />
            </React.StrictMode>
        );
    </script>
</body>
</html>
